> The more the merrier, right? We decided to mash two of the best cryptosytems
> together for the best product. Our new encryption scheme is up and running and
> this time it is unbreakable! To prove that, we have also released its source
> code and a test center where you can test it out!

> Author: **[DaysOfLife][author-profile]**

## Interacting with the server

At first the scheme looks somewhat convoluted, but it's also its weakness.

The parameters satisfy strict conditions, making them easy to reverse:

```
Welcome to the ECRSA test center. Your encrypted data will be sent soon.
Please check the logs for the parameters.
Generating your key...
Creating ECC params
Encrypted flag: 11527ef661b63f0e8df26e78d79b614cb63e834da05bf333856a97f81d74aec58aefbda52dd6ee164447cb3cd64869aee935d9e961ea12375354eea7e21a6790
IV: 2d2e1e8a88205995ce2d76d244c28b2b
N: 6977872954453287113318928946533004640573076971270404736649857554109814714767232598626781851567154954553736188657231769647898054950996488674893670519816653
ECRSA Ciphertext: Point(x=2851572783042418026133996814250879893796058672204604585672807372129430580698309059946087548171123066371647509247443388126483506717427455136382648462997156, y=6229895414423825093970708176923792736711251122090113458666591518448699655186597924150954711460449644605774495375106765029330485916590545376676075133841422)
Would you like to test the ECRSA curve?
[y/n]> y
Generating random point...
Point(x=4462129553869194635110347913537781447163673151204817501735057255299985150330059138351040776905457304373656070189763506501461514517702259280043082926076418, y=1012904040892509457148773549664059101097406279754569553936756270049573187157782900888372009243941138782308618768537282105721569482060963331594736944741842)
Thanks for testing!
```

## Browsing the sources

In the end, the flag is encrypted with AES:

```python
cipher = AES.new(key,AES.MODE_CBC,iv)
data = cipher.encrypt(pad(flag,16))
print(f"Encrypted flag: {data.hex()}")
```

The key is computed from a point on an elliptic curve:

```python
key = md5(str(g.x).encode()).digest()
iv = os.urandom(16)
print(f"IV: {iv.hex()}")
```

The curve itself has 128 bit random parameters `a` & `b`:

```python
ec = EllipticCurve(a,b,n)
g = getrandpoint(ec,p,q)
A = ec.multiply(g,e)
print(f"ECRSA Ciphertext: {A}")
```

The random point has a quadratic residue as abscissa.

```python
def getrandpoint(ec,p,q):
    num = random.randint(1,p*q)
    while legendre(expr(num),p) != 1 or legendre(expr(num),q) != 1:
        num = random.randint(1,p*q)
    return ec.lift_x(num,p,q)
print("Generating random point...")
print(getrandpoint(ec,p,q))
```

To reverse the encryption, we can compute the parameters `a`, `b`, `p`, `q` and `e` and reproduce the steps above.

## Factoring N

First, N is the product of `p` and `q`.

And N is composed of prime factors close to each other:

```python
def keygen(bits):
    # Returns RSA key in form ((e,n),(p,q))
    p = getPrime(bits // 2)
    while p % 4 == 1:
        p = next_prime(p)
    e = next_prime(p >> (bits // 4))
    q = next_prime(p)
    for i in range(50):
        q = next_prime(q)
    while q % 4 == 1:
        q = next_prime(q)
    n = p * q
    if n.bit_length() != bits:
        return keygen(bits)
    return (e,n),(p,q)
```

Online tools will factor N easily:

```python
p = 83533663600091712446566994191789220991430106051937633587789852519272240462807
q = 83533663600091712446566994191789220991430106051937633587789852519272240470779
e = next_prime(p >> (len(p.digits(2)) // 2), 2, 1)
```

## Computing the EC parameters

The server provides 2 points on the curve: the 2 necessary equations for the 2 unknown parameters a & b.

```python
def ec_parameters(p1, p2, n):
    x1, y1 = p1
    x2, y2 = p2
    a = ((y1 ** 2) - (x1 ** 3) - (y2 ** 2) + (x2 ** 3) % n) * pow(x1 - x2, -1, n)
    b = (y1 ** 2) - (x1 ** 3) - (a * x1)
    return (a % n, b % n)
```

## Finding the generator

Finally, the first point `A` is actually the product `e * g`, in the EC group.

It means that: `g = A * e^-1`. Here, the product and inverse of a particular meaning in the finite group of the EC.

Here, the inverse of `e` can be computed in the groups generated by `p` and `q` separately:

```python
GP = GF(p)
GQ = GF(q)
ecp = EllipticCurve(GP, [a, b])
ecq = EllipticCurve(GQ, [a, b])

ap = ecp(A[0], A[1])
aq = ecq(A[0], A[1])

ep_1 = inverse_mod(e, ecp.order())
eq_1 = inverse_mod(e, ecq.order())
```

And then we get the remainder of `A * e^-1` in both groups: the Chinese remainder theorem then provides the value of G.

```python
gx = crt([int(gp[0]), int(gq[0])], [p, q])
```

## Decrypting

This value can then be used as key for the decryption:

```python
key = md5(str(gx).encode()).digest()
cipher = AES.new(key,AES.MODE_CBC, IV)
flag = cipher.decrypt(CT)
```

> `HTB{Pr1M3_Pr0x1mIty_@nD_C0mP0s1T3_CuRv3?????=>s0_1nS3cUr3!!!}`

[author-profile]: https://app.hackthebox.eu/users/185587
