# ExploitedStream

> **An npm stream compromised dependencies long ago.**
> **Help us recover what this script is hiding.**

## Beautifying the script

We're given a oneline, vomit stream of a javascript file.

First of, indent:

```bash
uglifyjs -b -o exploitedstream.beautified.js exploitedstream.js
```

The javascript variables and function names are scrambled, and there are a few
tricks to mask the actual operations.

Yet two things stand out:

- there's a list of operations written in cleartext at the top of the script
- the function `_0x124e` is called all over the place: `_0x124e("0xa")`

`_0x124e` is short:

```javascript
var _0x124e = function(_0x55d687, _0x1fe12d) {
    _0x55d687 = _0x55d687 - 0;
    var _0x4c9c20 = _0x1d30[_0x55d687];
    return _0x4c9c20;
};
```

Where `_0x1d30` (renamed "call") is actually the list of operations. It looks like this
function is actually fetching operations by their indexes:

```javascript
var call = function(index, _0x1fe12d) {
    index = index - 0; // cast string to integer
    return operations[index];
};
```

This is fairly useless once we replace all the "0x0c" strings with integers
like `0x0c`. Instead, we directly fetch from the array:

```javascript
// from
output[_0x124e("0xb")]
// to
output[operations[0xb]]
```

```bash
perl -pe 's#_0x124e\("(0x.{1,2})"\)#operations[$1]#g' exploitedstream.beautified.js > exploitedstream.beautified.clarified.js
```

Testing this manually, the operations don't fit with the caller's instruction.
There's still some mystery process invoking `_0x1d30` (now renamed `operations`).

Indeed the operations' list is rotated 337 times:

```javascript
(function(iterable, iterations) {
    var rotate = function(counter) {
        while (--counter) {
            iterable["push"](iterable["shift"]());
        }
    };
    rotate(++iterations);
})(operations, 337);
```

We can remove it all and replace the original operations' array with the rotated array:

```javascript
// from
var operations = [ "utf8", "final", "cGFzc3dvcmRfaXNfdGhlX25hbWVfb2Zfb25lX25wbV9wYWNrYWdl",... ];
// to
var operations = [ "crypto", "aes-256-ctr", "createDecipher", "update", "hex", "utf8", ... ];
```

And in the end:

```javascript
// the original
output[_0x124e("0xb")](0, password_length)
// translates to
output["slice"](0, password_length)
// better yet
output.slice(0, password_length)
```

After replacing all occurences, defusing a few other tricks and removing extra
instructions [the code][clarified-code] is finally legit.

## Clues?

### Were they enough for my future me?

We're now looking at:

```javascript
try {
    const crypto = require("crypto");
    let password_length = 18;
    let blob = "H0Zlf54IiGaArHUnITtpu2wCABQffO4prWAOJTtAd...";

    let output = ascii_to_binary(blob);

    let o = +new Date() + "," + output.slice(0, password_length).toString().replace(/,/g, "").substring(0, password_length);
    let noxc = "83729c4575f56a8287c0b4e8ee5c33f8cb891ccaddcafb71ef5f7bd067f19d854ab16e0cb22460";

    console.log(decrypt(noxc, "aes-256-ctr", global.process.argv[2] || o))
} catch (err) {
    console.log(err);
}
```

Parts of the script require npm packages, so it cannot run on the dev console as is.

The script's final output is the plaintext version of `noxc`, decrypted thanks
to a key given as a cli argument.

The variable `for_future_me` contains a reminder / clue:

```bash
echo "cGFzc3dvcmRfaXNfdGhlX25hbWVfb2Zfb25lX25wbV9wYWNrYWdl" | base64 -d
password_is_the_name_of_one_npm_package
```

What package though?? The usual mind-spot is itching: bruteforce it with all
the package names!

### The supply-chain attack

Looking *only* at this script it was not obvious, but this challenge is strongly
inspired by a [well-known supply-chain attack][event-stream-article] on npm.

It targeted the "copay" wallet by hijacking one of its dependencies, "event-stream",
to inject a malicious dependency: "flatmap-stream".

The npm package names, dates, versions, make a little dictionary for a bruteforce
attack of the cipher. Actually any related / significant string.

## Bruteforcing

There are many options to automate the operations; here we'll use node / JS to
make the most out of this exercise and learn the related tools.

Let's start with a wordlist of all the package names that contain "stream":

```javascript
brute_decrypt(noxc, "aes-256-ctr", names.filter(name => name.includes('stream')));
```

```bash
node bruteforce.js
[+] Parameters:
    Password:undefined
    Algorithm: aes-256-ctr
    Process:[object process]
    Ciphertext: 83729c4575f56a8287c0b4e8ee5c33f8cb891ccaddcafb71ef5f7bd067f19d854ab16e0cb22460
[+] Bruteforcing...
[+] Password found!
    stream-accelerator
    HTB{0fbuSc4t1ng_1s_N0t_s3curE,1s_IT???}
(node:2999) [DEP0106] DeprecationWarning: crypto.createDecipher is deprecated.
```

It was enough!!

And here I was building a custom wordlist and planning on testing all 18
characters packages next.

And the `+new Date()` was bugging me... I thought I'd have to find a specific
timestamp to prefix this all, fearing it'd drag forever.

I'm so glad it ended at this stage! The challenge was fun through and through :)

[clarified-code]: exploited-stream.beautified.clarified.js
[event-stream-article]: https://medium.com/intrinsic-blog/compromised-npm-package-event-stream-d47d08605502
